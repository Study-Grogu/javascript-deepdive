# 12. 함수

함수는 일련의 과정을 문으로 구현하고 코드 불록으로 감싸서 하나의 실행 단위로 정의한 것이다.

함수는 코드를 블록으로 나누어 재사용하기 유용하다. 이렇게 코드를 재사용하면 유지보수의 편의가 증대되고, 코드의 신뢰성을 높일 수 있다.

자바스크립트에서 함수는 \*\*일급 객체(First-class Citizen)\*\*이다. 이는 함수가 변수에 할당될 수 있고, 다른 함수의 인수로 전달될 수 있으며, 다른 함수에 의해 반환될 수도 있음을 의미한다.

## 1. 함수 정의 (Function Definition)

함수를 정의하는 방법에는 여러 가지가 있다.

### 함수 선언문 (Function Declaration)

가장 일반적인 형태이며, `function` 키워드, 함수 이름, 매개변수 목록, 함수 본문으로 구성된다.

- **특징:** 호이스팅(Hoisting)이 발생한다. 즉, 코드가 실행되기 전에 함수 선언이 메모리의 최상단으로 끌어올려져, 함수가 선언된 위치보다 앞서서 호출할 수 있다.

<!-- end list -->

```javascript
// 함수 선언
function greet(name) {
  return `Hello, ${name}!`;
}

// 선언 전에 호출 가능 (호이스팅)
console.log(greet("World"));
```

### 함수 표현식 (Function Expression)

함수는 일급객체이기에, 변수 등에 값으로 할당할 수 있다.
이름이 없는 **익명 함수(Anonymous Function)**를 사용하는 것이 일반적이다.

- **특징:** 호이스팅되지 않는다. (정확히는 변수 선언 `var`, `let`, `const`의 호이스팅 규칙을 따르며, `let`과 `const`는 TDZ의 영향을 받아 할당 전에 접근할 수 없다.)

<!-- end list -->

```javascript
// 함수 표현식
const greet = function (name) {
  return `Hello, ${name}!`;
};

// 할당 이후에만 호출 가능
console.log(greet("World"));
```

### 화살표 함수 (Arrow Function) (ES6+)

ES6에서 도입된 더 간결한 함수 정의 문법이다.

- **특징:**
  - `function` 키워드 대신 `=>`를 사용한다.
  - 자신만의 `this` 바인딩을 갖지 않고, 상위 스코프의 `this`를 그대로 물려받는다(Lexical `this`).
  - `arguments` 객체를 생성하지 않는다.
  - `new` 키워드와 함께 생성자 함수로 사용할 수 없다.

<!-- end list -->

```javascript
// 화살표 함수
const add = (a, b) => {
  return a + b;
};

// 본문이 한 줄의 반환문일 경우, {}와 return 생략 가능
const subtract = (a, b) => a - b;

// 매개변수가 하나일 경우, () 생략 가능
const square = (x) => x * x;
```

---

## 2. 함수 호출 (Function Invocation)

함수 정의는 함수 객체를 생성할 뿐, 코드를 실행하지 않는다. 함수를 실행하려면 \*\*호출(Invocation)\*\*해야 한다. 함수 이름 뒤에 소괄호`()`를 붙여 호출한다.

- **매개변수(Parameter):** 함수를 정의할 때 선언하는 변수이다. (`function add(a, b)`)
- **인수(Argument):** 함수를 호출할 때 전달하는 실제 값이다. (`add(10, 5)`)

<!-- end list -->

```javascript
function add(a, b) {
  // a, b는 매개변수
  return a + b;
}

// 함수 호출
// 10, 5는 인수
const result = add(10, 5);

console.log(result); // 15
```

---

## 3. 참조에 의한 외부 상태 변경

자바스크립트에서 함수에 인수를 전달할 때, 값의 타입에 따라 다르게 동작한다.

### 원시 값 (Primitive Types)

`String`, `Number`, `Boolean`, `null`, `undefined`, `Symbol` 등 원시 값은 \*\*값에 의한 전달(Pass-by-value)\*\*로 동작한다. 함수 내부에서 매개변수의 값을 변경해도, 함수 외부의 원본 변수에는 아무런 영향을 미치지 않는다. (값이 복사되어 전달됨)

```javascript
function changeValue(primitiveVal) {
  primitiveVal = 100; // 함수 내부의 'primitiveVal' 변수만 변경됨
  console.log(`Inside: ${primitiveVal}`); // Inside: 100
}

let externalNum = 10;
changeValue(externalNum);
console.log(`Outside: ${externalNum}`); // Outside: 10 (외부 상태 변경 X)
```

### 객체 참조 값 (Object Types)

`Object`, `Array`, `Function` 등 객체 타입은 \*\*참조에 의한 전달(Pass-by-reference)\*\*과 유사하게 동작한다. (정확히는 "참조 값의 복사" 또는 "공유에 의한 전달" - Pass-by-sharing).

함수에 전달되는 것은 객체 자체가 아니라, 해당 객체를 가리키는 \*\*메모리 주소(참조 값)\*\*의 복사본이다.

- **외부 상태 변경 (O):** 함수 내부에서 매개변수(참조 값)를 통해 객체의 \*\*속성(Property)\*\*을 변경하면, 원본 객체가 변경된다.

  ```javascript
  function changeName(personObj) {
    // personObj는 externalPerson과 동일한 객체를 참조함
    personObj.name = "Bob"; // 참조하는 객체의 속성을 변경
  }

  let externalPerson = { name: "Alice" };
  console.log(`Before: ${externalPerson.name}`); // Before: Alice

  changeName(externalPerson);

  console.log(`After: ${externalPerson.name}`); // After: Bob (외부 상태 변경 O)
  ```

- **외부 상태 변경 (X):** 함수 내부에서 매개변수(참조 값) 자체를 **새로운 객체로 재할당**하는 것은 외부 변수에 영향을 주지 않는다.

  ```javascript
  function reassignObject(personObj) {
    // 함수 내부의 personObj 변수에 새로운 객체 참조를 할당함
    personObj = { name: "Charlie" };
  }

  let externalPerson = { name: "Alice" };
  reassignObject(externalPerson);
  console.log(externalPerson.name); // Alice (외부 상태 변경 X)
  ```

---

## 4. 자바스크립트 함수의 다양한 형태

자바스크립트 함수는 기본적인 선언과 호출 외에도, 특정 목적과 패턴에 따라 다양한 형태로 정의되고 활용된다.

---

### 1) 즉시 실행 함수 (IIFE)

\*\*IIFE (Immediately Invoked Function Expression)\*\*는 함수를 정의함과 동시에 즉시 호출하는 방식이다.

- **형태:** 함수 전체를 소괄호`()`로 감싸고, 바로 뒤에 호출 소괄호`()`를 붙인다.
- **주요 목적:**
  - **스코프 격리:** IIFE 내부에서 선언된 변수는 외부 전역 스코프를 오염시키지 않는다.
  - **데이터 캡슐화:** 외부에서 내부 변수에 직접 접근하는 것을 막아 초기화 코드나 모듈 패턴 등에 유용하게 사용된다.

<!-- end list -->

```javascript
(function () {
  const privateMessage = "이 변수는 외부에서 접근할 수 없다.";
  console.log("IIFE가 즉시 실행됨.");
  console.log(privateMessage);
})();

// console.log(privateMessage); // Error: privateMessage is not defined
```

---

### 2) 재귀 함수 (Recursive Function)

**재귀 함수**는 함수가 실행 중에 자기 자신을 다시 호출하는 함수이다.

- **구조:**

  1.  **종료 조건 (Base Case):** 재귀 호출을 멈추는 조건. 이 조건이 없으면 무한 루프에 빠져 **스택 오버플로(Stack Overflow)** 오류가 발생한다.
  2.  **재귀 호출 (Recursive Case):** 문제를 더 작은 단위로 쪼개어 자기 자신을 다시 호출하는 부분.

- **예시 (팩토리얼):**

<!-- end list -->

```javascript
function factorial(n) {
  // 1. 종료 조건 (Base Case)
  if (n <= 1) {
    return 1;
  }
  // 2. 재귀 호출 (Recursive Case)
  return n * factorial(n - 1);
}

console.log(factorial(5)); // 120 (5 * 4 * 3 * 2 * 1)
```

---

### 3) 중첩 함수 (Nested Function)와 클로저 (Closure)

**중첩 함수**는 말 그대로 함수 내부에 또 다른 함수가 정의된 구조이다.

**클로저**는 이 중첩 함수가 중요한 개념으로 확장된 것이다. 클로저는 \*\*"자신이 생성될 때의 환경(스코프)을 기억하는 함수"\*\*이다.

- **특징:**
  - 내부 함수는 외부 함수의 변수(매개변수 포함)에 접근할 수 있다.
  - 외부 함수의 실행이 종료된 후에도, 내부 함수가 반환되어 살아있다면, 내부 함수는 외부 함수의 스코프(변수)를 계속해서 기억하고 접근할 수 있다.
- **목적:** 상태를 은닉하고 유지(Stateful function), 모듈화, 커링(Currying) 등에 활용된다.

<!-- end list -->

```javascript
function createCounter() {
  let count = 0; // 외부 함수의 변수 (은닉된 상태)

  // 1. 중첩 함수
  function increment() {
    count++; // 외부 스코프의 'count' 변수를 참조
    return count;
  }

  return increment; // 내부 함수를 반환
}

// counter는 increment 함수(클로저)를 참조한다.
// createCounter의 실행은 끝났지만, 'count' 변수는 메모리에 남아있다.
const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

---

### 4) 콜백 함수 (Callback Function)

**콜백 함수**는 다른 함수의 인자로 전달되는 함수이며, 특정 작업이 완료된 후 "다시 호출(call back)"되도록 약속된 함수이다.
이 때 매개변수를 통해 콜백함수를 인자로 받는 함수는 고차함수이다.

<!-- end list -->

```javascript
const numbers = [1, 2, 3];
const doubled = numbers.map(function (num) {
  return num * 2;
});
console.log(doubled); // [2, 4, 6]

console.log("작업 시작");

// 1초 뒤에 실행될 콜백 함수를 전달
setTimeout(function () {
  console.log("1초 경과. 콜백 실행됨.");
}, 1000);

console.log("다음 작업 (콜백을 기다리지 않음)");
```

---

### 5) 순수 함수와 비순수 함수

함수형 프로그래밍에서 함수를 구분하는 중요한 기준이다.

#### 순수 함수 (Pure Function)

아래 두 가지 조건을 반드시 만족하는 함수이다.

1.  **동일한 입력에 대해 항상 동일한 출력을 반환한다.** (외부 상태에 의존하지 않음)
2.  **부수 효과(Side Effect)가 없다.** (외부 상태를 변경하지 않음)

<!-- end list -->

- **특징:** 예측 가능하고 테스트하기 쉬우며, 코드의 안정성을 높인다.

<!-- end list -->

```javascript
// 순수 함수
function add(a, b) {
  return a + b;
}

console.log(add(2, 3)); // 5 (언제, 어디서 호출하든 항상 5)
```

#### 비순수 함수 (Impure Function)

순수 함수의 조건 중 하나라도 만족하지 못하는 함수이다.

- **부수 효과 (Side Effect):** 함수가 실행되면서 함수 외부의 상태를 변경하거나 영향을 미치는 것.

  - 전역 변수나 객체 속성을 수정하는 경우
  - DOM 조작
  - `console.log()` (브라우저 콘솔이라는 외부 상태를 변경)
  - HTTP 요청, 파일 쓰기 등

- **예시 1: 외부 상태를 변경 (부수 효과)**

<!-- end list -->

```javascript
// 비순수 함수
let total = 0;

function addToTotal(num) {
  total += num; // 1. 외부 상태 'total'을 변경 (Side Effect)
  return total; // 2. 동일한 입력 '5'에도 'total' 상태에 따라 출력이 달라짐
}

console.log(addToTotal(5)); // 5
console.log(addToTotal(5)); // 10
```

- **예시 2: 외부 상태에 의존**

<!-- end list -->

```javascript
// 비순수 함수
const TAX_RATE = 0.1;

function calculateTax(price) {
  return price * TAX_RATE; // 외부 상수 'TAX_RATE'에 의존
}
// 만약 TAX_RATE가 상수가 아니라 let으로 선언되어 변경된다면,
// calculateTax(100)의 결과는 예측 불가능해진다.
```

- **예시 3: 예측 불가능한 결과**

<!-- end list -->

```javascript
// 비순수 함수
function getRandomNumber() {
  return Math.random(); // 동일한 입력(없음)에도 항상 다른 출력을 반환
}
```

---

# 18. 함수와 일급 객체

## 1) 일급 객체

### 일급 객체의 조건

1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임 생성이 가능하다.
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용될 수 있다.

일급 객체라 함은 그 자체가 완전한 객체라는 의미이다. 따라서 함수는 객체와 동일하게 사용될 수 있다.

## 2) 함수 객체의 프로퍼티

### arguments

arguments 프로퍼티 값은 arguments 객체이다. arguments 객체는 함수가 인자로 받은 정보들을 담고 있는 순환 가능한 유사배열 객체이다. arguments 프로퍼티를 참조하는 것은 폐지되었으며 함수 내부에서 지역 변수로 참조한다. arguments 객체는 매개변수의 수를 정해 둘 수 없는 가변적인 상황, 즉 가변 인자 함수를 구현할 때 유용하다. 하지만 es6의 rest 파라미터의 등장으로 그 역할이 줄어들었다.

### length

함수의 프로퍼티로써 length는 매개변수의 개수를 가리킨다.

### name

함수의 이름을 나타낸다. 익명 함수의 경우 es5에선 빈 문자열을, es6에선 식별자를 값으로 가진다.

### **proto** 접근자

모든 자바스크립트 객체는 \[\[Prototype\]\] 내부슬롯을 가진다.
**proto** 접근자는 \[\[Prototype\]\] 내부슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용된다.
