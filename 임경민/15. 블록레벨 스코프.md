# 새로운 변수 키워드와 블록레벨 스코프

## var 키워드의 문제점과 let, const의 등장

var는 다른 프로그래밍 언어의 변수 선언 방식과 다른 독특한 특징들 때문에 여러 가지 문제를 야기했다.

### 1. 함수 레벨 스코프 (Function-level Scope)

var로 선언된 변수는 오직 함수의 코드 블록만을 지역 스코프로 인정한다. 이는 if, for, while 문과 같은 코드 블록 내에서 선언된 var 변수가 블록 외부로 "새어 나가는" 현상을 만든다.

```javascript
// var의 함수 레벨 스코프 문제점
function varTest() {
  var x = 1;
  if (true) {
    var x = 2; // 이미 선언된 x를 다시 덮어씀
    console.log(x); // 2
  }
  console.log(x); // 2 (if 블록 밖에서도 값이 변경됨)
}

varTest();

for (var i = 0; i < 3; i++) {
  console.log(i); // 0, 1, 2
}
console.log(i); // 3 (for 루프가 끝났지만 i가 살아있음)
```

이러한 동작은 의도치 않게 변수 값이 변경되거나, 전역 변수를 남발하여 코드를 예측하기 어렵게 만드는 원인이 된다.

### 2. 변수 호이스팅 (Variable Hoisting)

var로 선언된 변수는 해당 스코프의 최상단으로 "끌어올려진" 것처럼 동작한다. 이를 호이스팅이라고 한다. 하지만 선언만 끌어올려지고 할당은 제자리에 남아있기 때문에, 변수 선언문 이전에 변수를 참조해도 에러가 발생하는 대신 undefined가 반환된다.

```javascript
console.log(myVar); // undefined (에러가 발생하지 않음)
var myVar = "Hello";
console.log(myVar); // "Hello"
```

이러한 동작은 코드의 흐름을 이해하기 어렵게 만들고, 잠재적인 버그의 원인이 될 수 있다.

### 3. 변수 중복 선언 허용

var는 같은 스코프 내에서 동일한 이름의 변수를 여러 번 선언해도 아무런 에러를 발생시키지 않는다. 이 경우, 나중에 선언된 변수가 이전 변수를 조용히 덮어쓰게 되어 의도치 않은 값 변경이 발생할 수 있다.

```javascript
var name = "Alice";
// ... 다른 코드 ...
var name = "Bob"; // 에러 없이 덮어쓰기 됨

console.log(name); // "Bob"
```

## let, const와 블록 레벨 스코프

이러한 var의 문제점들을 해결하기 위해 ES6에서 let과 const가 도입되었다.

### 1. 블록 레벨 스코프 (Block-level Scope)

let과 const의 가장 큰 특징은 블록 레벨 스코프를 따른다는 것이다. 이는 변수가 선언된 코드 블록({...}) 내에서만 유효하다는 의미이다.

```javascript
function letTest() {
  let x = 1;
  if (true) {
    let x = 2; // if 블록 스코프에 새로운 x가 선언됨
    console.log(x); // 2
  }
  console.log(x); // 1 (if 블록의 x는 외부 x에 영향을 주지 않음)
}

letTest();

for (let j = 0; j < 3; j++) {
  console.log(j); // 0, 1, 2
}
//console.log(j); // ReferenceError: j is not defined (j는 for 블록 밖에서 소멸됨)
```

이처럼 변수의 유효 범위가 명확해져 코드의 예측 가능성이 높아지고 부작용(side effect)을 줄일 수 있다.

### 2. 변수 중복 선언 금지

let과 const는 같은 스코프 내에서 동일한 이름의 변수를 중복해서 선언하는 것을 허용하지 않는다. 만약 중복 선언을 시도하면 SyntaxError가 발생하여 실수를 방지할 수 있다.

```javascript
let name = "Alice";
// let name = "Bob"; // SyntaxError: Identifier 'name' has already been declared 3. 일시적 사각지대 (Temporal Dead Zone, TDZ)
```

let과 const로 선언된 변수도 호이스팅이 되지만, var와는 다르게 동작한다. 변수가 선언되기 전에 참조하려고 하면 undefined가 아닌 ReferenceError가 발생한다. 스코프에 진입한 시점부터 변수 선언문에 도달하기 전까지 변수를 참조할 수 없는 이 구간을 **일시적 사각지대(TDZ)**라고 한다.

```javascript
// console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
let myLet = "Hello";
console.log(myLet); // "Hello"
```

TDZ는 변수를 선언하기 전에 사용하는 논리적 오류를 명확하게 알려주어 코드의 안정성을 높인다.

### let과 const의 차이점

let과 const는 블록 레벨 스코프를 갖는다는 공통점이 있지만, 재할당 가능 여부에서 중요한 차이가 있다.

- let: 재할당이 가능한 변수를 선언할 때 사용한다.
- const: **재할당이 불가능한 상수(constant)**를 선언할 때 사용한다. const로 선언된 변수는 반드시 선언과 동시에 초기화해야 한다.

```javascript
let count = 0;
count = 1; // 가능

const PI = 3.14;
// PI = 3.14159; // TypeError: Assignment to constant variable.
```

주의할 점: const는 재할당을 금지하는 것이지, 값의 변경을 막는 것은 아니다. 객체나 배열과 같은 참조 타입의 값을 const로 선언했을 때, 객체의 프로퍼티나 배열의 요소는 변경할 수 있다.

```javascript
const person = {
  name: "Alice",
  age: 30,
};

// 재할당은 불가능
// person = { name: "Bob" }; // TypeError

// 하지만 객체 내부의 프로퍼티 변경은 가능
person.name = "Bob";
console.log(person.name); // "Bob"
```

## 결론: var 대신 let과 const를 사용해야 하는 이유

1. 스코프 관리: 블록 레벨 스코프로 변수의 유효 범위를 명확히 하여 의도치 않은 값 변경을 방지한다.
2. 안정성 향상: TDZ와 중복 선언 금지로 인해 잠재적인 버그를 컴파일 단계에서 발견할 수 있다.
3. 코드 가독성: const를 사용함으로써 이 변수는 재할당되지 않을 것이라는 의도를 명확히 드러내 코드의 가독성과 유지보수성을 높인다.

따라서 var 키워드를 사용하지 않을 것, 그리고 const를 주로 사용하되 재할당이 필요한 경우에만 let을 사용할 것을 권장(강제)한다.
