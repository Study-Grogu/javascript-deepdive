# 19. 프로토타입

자바스크립트는 **프로토타입 기반의 객체지향 프로그래밍 언어**다. 클래스(Class)가 없던 시절(ES6 이전)부터 프로토타입을 통해 상속과 객체 간의 관계를 구현해왔다. ES6의 `class` 문법 역시 내부적으로는 프로토타입을 기반으로 동작하는 문법적 설탕(Syntactic Sugar)이다.

## 1 객체지향 프로그래밍

객체지향 프로그래밍은 실세계의 실체(사물)를 인식하는 철학적 사고를 프로그래밍에 접목한 것이다.

- **객체(Object):** 속성(State/Property)과 동작(Behavior/Method)을 하나의 논리적인 단위로 묶은 복합적인 자료구조.
- 각 객체는 독립적이지만, 다른 객체와 관계를 맺거나 메시지를 주고받을 수 있다.

## 2 상속과 프로토타입

상속(Inheritance)은 객체지향의 핵심으로, **코드의 재사용**을 목적으로 한다.

- **문제점:** 생성자 함수로 객체를 여러 개 생성할 때, 메서드를 인스턴스마다 중복 생성하면 메모리가 낭비된다.
- **해결책:** 자바스크립트는 \*\*프로토타입(Prototype)\*\*을 통해 상속을 구현한다. 모든 인스턴스가 공통적으로 사용할 메서드나 프로퍼티를 프로토타입 객체에 미리 저장해 두고, 인스턴스는 이를 공유해서 사용한다.

## 3 프로토타입 객체

프로토타입 객체(줄여서 프로토타입)는 **상위(부모) 객체의 역할**을 하는 객체다. 다른 객체에 공유 프로퍼티를 제공한다.

### `__proto__` 접근자 프로퍼티

- 모든 객체는 `[[Prototype]]`이라는 내부 슬롯을 가진다. 이는 객체 생성 시 결정되며 상속을 구현하는 핵심 고리다.
- **접근:** `[[Prototype]]` 내부 슬롯에 직접 접근할 수 없으므로, `__proto__` 접근자 프로퍼티를 통해 간접적으로 접근한다.
- **주의:** 코드에서 직접 `obj.__proto__`를 사용하는 것은 권장되지 않는다. 대신 `Object.getPrototypeOf(obj)`를 사용하는 것이 좋다.

### 함수 객체의 `prototype` 프로퍼티

- **함수 객체만이 소유**하는 프로퍼티다.
- 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.
- 일반 객체나 화살표 함수(Arrow Function) 등 `non-constructor`는 이 프로퍼티가 없다.

### 프로토타입의 `constructor` 프로퍼티와 생성자 함수

- 모든 프로토타입은 `constructor` 프로퍼티를 갖는다.
- 이 프로퍼티는 **자신을 참조하고 있는 생성자 함수**를 가리킨다.
- 즉, 인스턴스는 프로토타입을 통해 자신의 생성자 함수에 접근할 수 있다.

## 4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

`new` 연산자 없이 리터럴(`{}`, `[]`, `function(){}`)로 생성된 객체도 프로토타입이 존재한다.

- 리터럴로 생성된 객체도 가상의 생성자 함수(`Object`, `Array` 등)와 연결된다.
- 예: `const obj = {};`는 사실상 `Object` 생성자 함수와 연결되며, `Object.prototype`을 상속받는다.

## 5 프로토타입의 생성 시점

프로토타입은 **생성자 함수가 생성되는 시점**에 더불어 생성된다. 프로토타입과 생성자 함수는 단짝처럼 언제나 쌍으로 존재한다.

### 사용자 정의 생성자 함수와 프로토타입 생성 시점

- 함수 정의가 평가되어 함수 객체가 생성되는 시점(런타임 이전에 호이스팅 될 때 혹은 실행될 때)에 프로토타입도 즉시 생성된다.

### 빌트인 생성자 함수와 프로토타입 생성 시점

- `Object`, `String`, `Number` 등 빌트인 생성자 함수는 전역 객체(브라우저에서는 window, Node.js에서는 global)가 생성되는 시점에 생성된다. 이때 프로토타입도 함께 만들어진다.

## 6 객체 생성 방식과 프로토타입의 결정

객체를 만드는 방법은 다양하지만, 추상 연산 `OrdinaryObjectCreate`에 의해 프로토타입이 결정되는 원리는 같다.

### 객체 리터럴에 의해 생성된 객체의 프로토타입

- `Object.prototype`을 프로토타입으로 갖는다.

### Object 생성자 함수에 의해 생성된 객체의 프로토타입

- `new Object()`로 생성하면 `Object.prototype`을 프로토타입으로 갖는다 (객체 리터럴과 동일).

### 생성자 함수에 의해 생성된 객체의 프로토타입

- `new Person()`처럼 사용자 정의 생성자 함수를 사용하면, 생성자 함수의 `prototype` 프로퍼티(`Person.prototype`)가 가리키는 객체가 프로토타입이 된다.

## 7 프로토타입 체인

자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘이다.

- 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때, 해당 객체에 프로퍼티가 없으면 **`[[Prototype]]` 내부 슬롯의 참조를 따라 상위 프로토타입으로 이동하며 검색**한다.
- 최상위는 언제나 `Object.prototype`이다. (`Object.prototype`의 프로토타입은 `null`)
- 이를 **프로토타입 체인**이라 한다.

## 8 오버라이딩과 프로퍼티 섀도잉

- **오버라이딩(Overriding):** 상위 클래스의 메서드를 하위 클래스가 재정의하는 것.
- **섀도잉(Property Shadowing):** 인스턴스에 프로토타입과 같은 이름의 프로퍼티를 추가하면, 프로토타입의 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티가 추가되어 상위 프로퍼티를 가린다(Shadow).

<!-- end list -->

```javascript
const Person = (function () {
  function Person(name) {
    this.name = name;
  }
  Person.prototype.sayHello = function () {
    console.log(`Hi! My name is ${this.name}`);
  };
  return Person;
})();

const me = new Person("Lee");

// 인스턴스 메서드 추가 (섀도잉 발생)
me.sayHello = function () {
  console.log(`Hey! I'm ${this.name}`);
};

me.sayHello(); // "Hey! I'm Lee" (인스턴스 메서드 호출)
```

## 9 프로토타입의 교체

프로토타입은 동적으로 변경할 수 있다. 이는 객체 간의 상속 관계를 동적으로 변경할 수 있음을 의미한다.

### 생성자 함수에 의한 프로토타입의 교체

- 생성자 함수의 `prototype` 프로퍼티에 다른 객체를 할당한다.
- **주의:** 교체된 객체에는 `constructor` 프로퍼티가 없으므로 `constructor` 링크가 파괴된다.

### 인스턴스에 의한 프로토타입의 교체

- `Object.setPrototypeOf(instance, newProto)`를 사용하여 이미 생성된 객체의 프로토타입을 바꾼다.
- 이 역시 `constructor` 연결이 깨지며, 성능상 좋지 않으므로 지양한다.

## 10 instanceof 연산자

```javascript
객체 instanceof 생성자함수;
```

- 우변의 생성자 함수의 `prototype` 프로퍼티에 바인딩된 객체가, 좌변 객체의 **프로토타입 체인 상에 존재**하면 `true`, 아니면 `false`를 반환한다.

## 11 직접 상속

### Object.create에 의한 직접 상속

- 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.
- `new` 연산자 없이 객체를 생성하거나, 프로토타입 체인의 종점(`null`)을 상속받는 객체를 만들 때 유용하다.

### 객체 리터럴 내부에서 `__proto__`에 의한 직접 상속 (ES6)

- `Object.create`가 번거로울 때 리터럴 내부에서 바로 상속 대상을 지정할 수 있다.
  ```javascript
  const obj = {
    y: 20,
    __proto__: myProto, // myProto를 상속받음
  };
  ```

## 12 정적 프로퍼티/메서드

생성자 함수도 객체이므로 프로퍼티와 메서드를 가질 수 있다. 이를 정적(Static) 프로퍼티/메서드라 한다.

- 생성자 함수가 직접 소유하며, **인스턴스가 참조하거나 호출할 수 없다.**
- 예: `Object.create()`, `Object.keys()` 등은 `Object` 생성자 함수의 정적 메서드이므로 인스턴스에서 호출 불가.

## 13 프로퍼티 존재 확인

### in 연산자

- 객체 내에 특정 프로퍼티가 존재하는지 확인한다.
- **특징:** 상속받은 **프로토타입 체인 상의 모든 프로퍼티**를 확인한다.
  ```javascript
  "toString" in {}; // true (Object.prototype.toString)
  ```

### Object.prototype.hasOwnProperty 메서드

- 객체 고유의 프로퍼티(Own Property)인 경우에만 `true`를 반환한다. 상속받은 프로퍼티는 `false`.

## 14 프로퍼티 열거

### for...in 문

- 객체의 모든 프로퍼티를 순회한다.
- **특징:** 프로토타입 체인 상의 프로퍼티 중 `[[Enumerable]]` 속성이 `true`인 프로퍼티까지 모두 열거한다.

### Object.keys/values/entries 메서드

- 객체 **자신의 고유 프로퍼티**만 열거할 때 권장된다.
- `Object.keys(obj)`: 키 배열 반환
- `Object.values(obj)`: 값 배열 반환 (ES8)
- `Object.entries(obj)`: `[키, 값]` 쌍의 배열 반환 (ES8)
