# 프로토타입

<strong>자바스크립트는 프로토타입 기반언어</strong><br>
→ 객체끼리 상속 관계를 형성할 때 프로토타입 체인을 이용한다.<br>
→ 자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 "모든것" 이 객체다.<br>
원시 타입의 값을 제외한 나머지 값들은 모두 객체다.

추상화 : 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것

→ 객체지향 프로그래밍은 객체의 상태(state)를 나타내는 데이터와 상태 데이터르 조작할 수 있는 동작을 하나의 논리적인 단위로 묶어 생각한다. 따라서 객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조라고 할 수 있다. <br>
이떄 객체의 상태 데이터를 프로퍼티, 동작을 메서드라 부른다.

---

상속 : 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.

프로토 타입 객체
→ 객체지향 프로그래밍의 근간을 이루는 객체 간 송속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.

Object.prototype<br>
→ 모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여있다. 자바스크립트 엔진은 객체의 프로퍼티(메서드 포함)에 접근 하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 **proto** 접근자 프로퍼티가 가리키는 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 object.prototype이며, 이 객체의 프로퍼티와 메서드는 모든 객체에 상속된다.

함수 객체의 프로토타입 프로퍼티

```js
(function () {}).hasOwnProperty("prototype"); //true

({}).hasOwnProperty("prototype"); //false
```

프로토타입의 constructor 프로퍼티와 생성자 함수

```js
function person(name) {
  this.name = name;
}

const me = new Person("lee");
console.log(me.constructor === person); //true
```

person 생성자 함수는 me 객체를 생성했다. 이때 me 객체는 프로토타입의 constructor 프로퍼티를 통해 생성자 함수와 연결된다.<br>
me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로토타입인 person.prototype에는 constructor 프로퍼티가 있다. 따라서 me 객체는 프로토타입인 person.prototype의 constructor 프로퍼티를 상속받아 사용할 수 있다.

```js
//foo 함수는 function 생성자 함수로 생성한 함수 객체가 아니라 함수 선언문으로 생성했다.
function foo() {}

// 하지만 constructor 프로퍼티를 통해 확인해보는 함수 foo의 생성자 함수는 function 생성자 함수다.
console.log(foo.constructor === function) //true
```

→ 리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하다 . 따라서 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖는다. 프로토타입은 생성자 함수와 더불어 생성되며 prototype,constructor 프로퍼티에 의해 연결되어 있기 때문이다. 다시말해 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존대한다.

| 리터럴 표기법      | 생성자 함수 | 프로토 타입        |
| ------------------ | ----------- | ------------------ |
| 객체 리터럴        | object      | object.prototype   |
| 함수 리터럴        | Function    | Function.prototype |
| 배열 리터럴        | Array       | Array.prototype    |
| 정규 표현식 리터럴 | RegExp      | RegExp.prototype   |

→ 프로토타입은 생성자 함수가 생성되는 시점에서 더불어 생성된다.

---

<br>
프로토 타입 체인 <br>
→ 자바스크립는 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라고 한다. 
프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘이다.

1. 스코프 체인과 혼동하면 안됨!

   - 스코프 체인 -> 변수를 찾는 경로 (함수/렉시컬 환경기반)
   - 스코프타입체인 -> 프로퍼티/메서드를 찾는 경로(객체기반)
     둘은 목적과 동작 방식이 완전히 다름

2. 프로토타입 체인의 종점

   마지막 객체는 반드시 Object.prototype이고,그 위는 null 이다.

```js
Object.getPrototypeOf(Object.prototype); // null

//즉, 체인 끝에 도달한 뒤에도 없으면 → undefined
```

3. 모든 함수는 prototype을 자동으로 가진다

```js
function Foo() {}
Foo.prototype; // 존재 (프로토타입 객체)

//그래서 함수로 만든 모든 객체에는
//프로토타입 체인이 생성된다.
```

4.  상속 구조를 효율적으로 구현하는 메커니즘

    같은 메서드를 모든 객체에 복사하지 않고
    하나의 프로토타입을 공유<br> ⇒ 메모리 절약 및 성능 향상
    JS의 상속은 class가 아니라 prototype 기반

5.  체인 길이가 길어지면 성능에 영향<br>
    프로퍼티를 찾기 위해 chain을 계속 타고 올라가므로 잘못 설계하면 검색 비용 증가 → 성능 저하 가능

---

instanceof 연산자<br>
→ instanceof 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 만약 우변의 피연산자가 함수가 아닌 경우 TypeError가 발생한다.<br>
우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하며 true로 평가되고 , 그렇지 않은 경우에는 false로 평가된다.

```js
function Foo() {}
const a = new Foo();

Object.setPrototypeOf(a, Array.prototype);

console.log(a instanceof Foo); // false
console.log(a instanceof Array); // true

//객체를 만든 다음 prototype을 바꾸면 결과가 변한다
```

```js
class Person {}
const p = new Person();
console.log(p instanceof Person); // true
//class 문법에서도 내부적으로는 prototype 기반
```
