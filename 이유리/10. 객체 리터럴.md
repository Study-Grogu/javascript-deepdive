# 10. 객체 리터럴

### 📍 객체

자바스크립트의 객체는 키(key)와 값(value)으로 구성된 프로퍼티들의 집합이다.
객체는 **변경 가능한 값(mutable value)** 이며 **일급 객체**이므로 **값**으로 취급할 수 있다.

프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드(method)라고 부른다. 메서드는 객체에 묶여있는 함수를 의미한다.

- 프로퍼티: 객체의 상태를 나타내는 값(data)
- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

---

### 📍 객체 리터럴에 의한 객체 생성

자바스크립트는 **프로토타입 기반 객체지향 언어**로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다. 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다.

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

> 리터럴: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법

> 객체 리터럴: 객체를 생성하기 위한 표기법

객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다.
코드 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않지만, 객체 리터럴은 **값으로 평가되는 표현식**이기 때문에 객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.

---

### 📍 프로퍼티 접근

프로퍼티에 접근하는 방법은 두 가지 존재한다.

- 마침표 표기법: 마침표 프로퍼티 접근 연산자(.) 사용
- 대괄호 표기법: 대괄호 프로퍼티 접근 연산자([...]) 사용

접근 연산자의 좌측에 객체로 평가되는 표현식을 기술하고, 우측 또는 대괄호 프로퍼티 접근 연산자의 내부에는 프로퍼티 키를 지정한다.

```js
// 마침표 표기법
console.log(person.name);

// 대괄호 표기법
console.log(person["name"]);
```

- 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 따옴표로 감싸지 않으면 자바스크립트 엔진은 식별자로 해석한다.

- 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름이라면 반드시 대괄호 표기법을 사용해야 한다.

- 객체에 존재하지 않는 프로퍼티에 접근하면 **undefined**를 반환한다.

---

### 📍 ES6 객체 리터럴 확장 기능

#### 1️⃣ 프로퍼티 축약 표현

프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다. 프로퍼티 키는 변수 이름으로 자동 생성된다.

```js
// ES5
var x = 1,
  y = 2;

var obj = {
  x: x,
  y: y,
};
```

```js
// ES6 프로퍼티 축약 표현
const obj = { x, y };
```

</br>

#### 2️⃣ 계산된 프로퍼티 이름

문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. 이때 프로퍼티 키로 사용할 표현식을 대괄호([...])로 묶어야 하고, 이것을 계산된 프로퍼티 이름이라고 한다.

**[ ES5 ]**

계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성하려면 객체 리터럴 외부에서 대괄호([...]) 표기법을 사용해야 한다.

> 대괄호 표기법으로 key 생성: 객체 생성 후 추가

```js
var key = "age";

var person = {
  name: "yuri",
};

person[key] = 26; // 계산된 프로퍼티 key
```

> 표현식을 사용하여 key 생성: 객체 생성 후 추가

```js
var prefix = "user";
var i = "1";

var data = {};

name[prefix + i] = "yuri";

console.log(data); // { user1: "yuri" }
```

**[ ES6 ]**

객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다.

> 객체 리터럴 내부에서 바로 계산된 key 사용

```js
const key = "age";

const person = {
  name: "yuri",
  [key]: 26, // 계산된 프로퍼티 이름
};

console.log(person); // { name: "yuri", age: 26}
```

> 표현식을 사용하여 key 생성: 객체 내부에서 바로 추가

```js
const prefix = "user";
const i = 1;

const data = {
  [prefix + index]: "yuri",
};

console.log(data); // { user1: "yuri"}
```

</br>

#### 3️⃣ 메서드 축약 표현

**[ ES5 ]**

- 메서드를 정의할 때 반드시 function 키워드를 사용한다.

```js
var calculator = {
  add: function (a, b) {
    return a + b;
  },
};
```

**[ ES6 ]**

- 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다.

```js
const calculator = {
  add(a, b) {
    return a + b;
  },
};
```

메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다.

=> 겉모습은 같아보이지만 내부적으로 동작이 조금 다르다.
